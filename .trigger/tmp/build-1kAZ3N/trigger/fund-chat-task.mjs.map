{
  "version": 3,
  "sources": ["../../../../trigger/fund-chat-task.ts"],
  "sourcesContent": ["import { randomUUID } from \"node:crypto\";\nimport { schemaTask } from \"@trigger.dev/sdk\";\nimport { z } from \"zod\";\nimport {\n  encodeFundChatRealtimeChunk,\n  fundChatRealtimeStream,\n  type FundChatRealtimeChunk,\n} from \"./streams\";\n\nconst payloadSchema = z.object({\n  userId: z.string(),\n  chatId: z.string(),\n  userText: z.string().min(1),\n  model: z.string().optional(),\n  isNewChat: z.boolean().optional(),\n  turnstileToken: z.string().optional(),\n  policyPrechecked: z.boolean().optional(),\n});\n\nconst TASK_MAX_DURATION_SECONDS = Number.parseInt(\n  process.env.TRIGGER_FUND_CHAT_MAX_DURATION_SECONDS || \"1800\",\n  10\n);\nconst UPSTREAM_TIMEOUT_MS = Number.parseInt(\n  process.env.TRIGGER_UPSTREAM_TIMEOUT_MS || \"1800000\",\n  10\n);\nconst UPSTREAM_RETRIES = Number.parseInt(\n  process.env.TRIGGER_UPSTREAM_RETRIES || \"1\",\n  10\n);\nconst ARTIFACT_PATH_REGEX = /(?:backend\\/|front\\/)?artifacts\\/[A-Za-z0-9._/-]+\\.(?:html|csv)/g;\n\nfunction normalizeBase(rawBase: string) {\n  const trimmed = rawBase.replace(/\\/+$/, \"\");\n  if (trimmed.endsWith(\"/v1/chat/completions\")) {\n    return trimmed.replace(/\\/v1\\/chat\\/completions$/, \"\");\n  }\n  return trimmed;\n}\n\nfunction wait(ms: number) {\n  return new Promise<void>((resolve) => setTimeout(resolve, ms));\n}\n\nfunction mergeSignals(signals: Array<AbortSignal | null | undefined>) {\n  const active = signals.filter(Boolean) as AbortSignal[];\n  if (active.length === 0) {\n    return undefined;\n  }\n  if (active.length === 1) {\n    return active[0];\n  }\n\n  const controller = new AbortController();\n  for (const signal of active) {\n    if (signal.aborted) {\n      controller.abort(signal.reason);\n      return controller.signal;\n    }\n    signal.addEventListener(\n      \"abort\",\n      () => {\n        if (!controller.signal.aborted) {\n          controller.abort(signal.reason);\n        }\n      },\n      { once: true }\n    );\n  }\n  return controller.signal;\n}\n\nfunction buildFetchErrorMessage(base: string, error: unknown) {\n  const err = error as\n    | (Error & { code?: string; cause?: { code?: string; message?: string } })\n    | undefined;\n  const code = err?.cause?.code || err?.code || \"\";\n  const message = err?.cause?.message || err?.message || String(error);\n  const prefix = code ? `${code}: ` : \"\";\n  return `Upstream fetch failed (${base}/v1/chat/completions): ${prefix}${message}`;\n}\n\ntype UpstreamDeltaPayload = {\n  choices?: Array<{\n    delta?: UpstreamChoiceDelta;\n  }>;\n};\n\ntype UpstreamChoiceDelta = {\n  content?: string | Array<{ text?: string }>;\n  reasoning?: string;\n};\n\nfunction extractSsePayload(eventBlock: string) {\n  const lines = eventBlock.split(/\\r?\\n/);\n  const dataLines = lines\n    .filter((line) => line.startsWith(\"data:\"))\n    .map((line) => line.slice(5).trim());\n  if (dataLines.length === 0) {\n    return \"\";\n  }\n  return dataLines.join(\"\\n\").trim();\n}\n\nfunction extractTextDelta(delta: UpstreamChoiceDelta | undefined) {\n  const content = delta?.content;\n  if (typeof content === \"string\") {\n    return content;\n  }\n  if (!Array.isArray(content)) {\n    return \"\";\n  }\n  return content\n    .map((part) => (typeof part?.text === \"string\" ? part.text : \"\"))\n    .join(\"\");\n}\n\nfunction extractReasoningDelta(delta: UpstreamChoiceDelta | undefined) {\n  return typeof delta?.reasoning === \"string\" ? delta.reasoning : \"\";\n}\n\nfunction extractArtifactsFromText(text: string) {\n  return Array.from(new Set((text.match(ARTIFACT_PATH_REGEX) || []) as string[]));\n}\n\nasync function appendRealtimeChunk(chunk: FundChatRealtimeChunk) {\n  await fundChatRealtimeStream.append(encodeFundChatRealtimeChunk(chunk));\n}\n\nasync function streamUpstreamResponse(response: Response) {\n  if (!response.body) {\n    throw new Error(\"Upstream returned empty stream body\");\n  }\n\n  const textPartId = `text_${randomUUID()}`;\n  const reasoningPartId = `reasoning_${randomUUID()}`;\n  const reader = response.body.getReader();\n  const decoder = new TextDecoder();\n  let pending = \"\";\n  let sawDone = false;\n  let text = \"\";\n  let textStarted = false;\n  let reasoningStarted = false;\n\n  const consumeEvent = async (eventBlock: string) => {\n    const payload = extractSsePayload(eventBlock);\n    if (!payload) {\n      return;\n    }\n    if (payload === \"[DONE]\") {\n      sawDone = true;\n      return;\n    }\n\n    let parsed: UpstreamDeltaPayload | null = null;\n    try {\n      parsed = JSON.parse(payload) as UpstreamDeltaPayload;\n    } catch {\n      return;\n    }\n\n    const delta = parsed?.choices?.[0]?.delta;\n    const reasoningDelta = extractReasoningDelta(delta);\n    if (reasoningDelta) {\n      if (!reasoningStarted) {\n        await appendRealtimeChunk({\n          type: \"reasoning-start\",\n          id: reasoningPartId,\n        });\n        reasoningStarted = true;\n      }\n      await appendRealtimeChunk({\n        type: \"reasoning-delta\",\n        id: reasoningPartId,\n        delta: reasoningDelta,\n      });\n    }\n\n    const textDelta = extractTextDelta(delta);\n    if (textDelta) {\n      if (!textStarted) {\n        await appendRealtimeChunk({\n          type: \"text-start\",\n          id: textPartId,\n        });\n        textStarted = true;\n      }\n      await appendRealtimeChunk({\n        type: \"text-delta\",\n        id: textPartId,\n        delta: textDelta,\n      });\n      text += textDelta;\n    }\n  };\n\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n\n    pending += decoder.decode(value, { stream: true });\n    const events = pending.split(/\\r?\\n\\r?\\n/);\n    pending = events.pop() || \"\";\n\n    for (const event of events) {\n      await consumeEvent(event);\n      if (sawDone) {\n        break;\n      }\n    }\n    if (sawDone) {\n      break;\n    }\n  }\n\n  pending += decoder.decode();\n  if (!sawDone && pending.trim()) {\n    await consumeEvent(pending);\n  }\n\n  if (reasoningStarted) {\n    await appendRealtimeChunk({\n      type: \"reasoning-end\",\n      id: reasoningPartId,\n    });\n  }\n  if (textStarted) {\n    await appendRealtimeChunk({\n      type: \"text-end\",\n      id: textPartId,\n    });\n  }\n\n  return text;\n}\n\nexport const fundChatTask = schemaTask({\n  id: \"fund-chat-task\",\n  schema: payloadSchema,\n  maxDuration: TASK_MAX_DURATION_SECONDS,\n  run: async (\n    { userId, chatId, userText, model, isNewChat, turnstileToken, policyPrechecked },\n    { signal }\n  ) => {\n    const base = process.env.CLAUDE_CODE_API_BASE\n      ? normalizeBase(process.env.CLAUDE_CODE_API_BASE)\n      : \"\";\n    const token = process.env.CLAUDE_CODE_GATEWAY_TOKEN || \"\";\n    if (!base) {\n      throw new Error(\"Missing CLAUDE_CODE_API_BASE\");\n    }\n    if (!token) {\n      throw new Error(\"Missing CLAUDE_CODE_GATEWAY_TOKEN\");\n    }\n\n    const headers: Record<string, string> = {\n      \"content-type\": \"application/json\",\n      authorization: `Bearer ${token}`,\n      \"x-chat-id\": chatId,\n      \"x-chat-new\": isNewChat ? \"true\" : \"false\",\n    };\n    if (turnstileToken?.trim()) {\n      const token = turnstileToken.trim();\n      headers[\"x-turnstile-token\"] = token;\n      headers[\"cf-turnstile-response\"] = token;\n    }\n    if (process.env.INTERNAL_TASK_KEY) {\n      headers[\"x-internal-task-key\"] = process.env.INTERNAL_TASK_KEY;\n      if (policyPrechecked) {\n        headers[\"x-policy-prechecked\"] = \"1\";\n      }\n    }\n\n    const requestBody = JSON.stringify({\n      model: model || \"gpt-5-codex\",\n      stream: true,\n      messages: [{ role: \"user\", content: userText }],\n    });\n    const timeoutSignal =\n      Number.isFinite(UPSTREAM_TIMEOUT_MS) && UPSTREAM_TIMEOUT_MS > 0\n        ? AbortSignal.timeout(UPSTREAM_TIMEOUT_MS)\n        : undefined;\n    const requestSignal = mergeSignals([signal, timeoutSignal]);\n    const retries = Number.isFinite(UPSTREAM_RETRIES) && UPSTREAM_RETRIES > 0 ? UPSTREAM_RETRIES : 0;\n\n    let response: Response | null = null;\n    let lastNetworkError: unknown;\n    for (let attempt = 0; attempt <= retries; attempt += 1) {\n      try {\n        response = await fetch(`${base}/v1/chat/completions`, {\n          method: \"POST\",\n          headers,\n          body: requestBody,\n          signal: requestSignal,\n        });\n        break;\n      } catch (error) {\n        lastNetworkError = error;\n        if (attempt >= retries || requestSignal?.aborted) {\n          break;\n        }\n        await wait(Math.min(1000 * 2 ** attempt, 3000));\n      }\n    }\n\n    if (!response) {\n      throw new Error(buildFetchErrorMessage(base, lastNetworkError));\n    }\n\n    if (!response.ok) {\n      const details = await response.text().catch(() => \"\");\n      throw new Error(`Upstream failed (${response.status}): ${details || response.statusText}`);\n    }\n\n    const text = await streamUpstreamResponse(response);\n    const artifacts = extractArtifactsFromText(text);\n\n    return {\n      userId,\n      chatId,\n      text,\n      artifacts,\n    };\n  },\n});\n"],
  "mappings": "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",
  "names": ["token"]
}
